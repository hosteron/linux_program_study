0	标准输入	STDIN_FILENO	stdin
1	标准输出	STDOUT_FILENO	stdout
2	标准错误	STDERR_FILENO	stderr
针对stdout调用freopen，无法确保变量的值仍为1
IO调用操作的4个主要系统调用
open, read , write , close 还有一个瑞士军刀一样的ioctl
-------------------一-----------------------------
O_RDONLY	以只读方式打开
O_WRONLY	以只写方式打开
O_RDWR		以读写方式打开
-------------------二-----------------------------
O_CLOEXEC	设置close-on-exec标志
在多线程程序中执行fcntl()的F_GETFD和F_SETFD操作可能导致竞争状态，使用O_CLOEXEC标志可以避免这一点
场景是：线程甲打开一文件描述符，尝试为该描述符标记close-on-exec标志，于此同时，线程乙执行fork()调用，然后调用exec()执行任一个程序（假设在甲打开文件描述符和调用
fcntl()设置close-on-exec标志之间，某乙成功执行了fork()和exec()操作），此类竞争可能会在无意间将打开的文件描述符泄露给不安全的程序
O_CREAT		若文件不存在则创建之
即使以只读方式打开，次标志依然有效，如果open()中指定了O_CREAT标志，那么还需要提供mode参数，否则，会将文件权限设置成栈中的某个随机值
O_DIRECT	无缓冲的输出输入
无系统缓冲的文件IO操作，<fcntl.h>中，必须定义_GNU_SOURCE功能测试宏
O_DIRECTORY	如果pathname不是目录，则失败
这一标志为了实现opendir()函数,定义在<fcntl.h>,必须定义_GNU_SOURCE功能测试宏
O_EXCL		结合O_CREAT参数使用，专门用于创建文件
此标志与O_CREAT标志结合使用表明如果文件已经存在，则不会打开文件，且open（）函数调用失败，并返回错误，errno=EEXIST,换言之，此标志确保调用者是创建文件的进程，如果open()调用时同时指定了O_EXCL和O_CREAT,且pathname是符号链接
则调用失败，errno=EEXIST,之所以这样规定，是要求有特权的应用程序在已知目录下创建文件，从而消除了如下安全隐患，使用符号链接打开文件会导致在另一个位置创建文件
O_LARGEFILE	在32位系统中使用此标志打开大文件，在64位系统中无效的
O_NOATIME	调用read()时，不修改文件的最近访问时间
在读文件时，不更新文件的最近访问时间，它旨在为索引和备份程序服务，该标志的使用能够显著减少磁盘的活动量，省却了既要读取文件内容，又要更新文件i-node结构中最近访问时间的繁琐，进而节省了磁头在磁盘上的反复寻道时间
mount()函数中MS_NOATIME标志和FS_NOATIME_FL标志与O_NOATIME标志功能类似，<fcntl.h>,_GNU_SOURCE
O_NOCTTY	不要让pathname（所指向的终端设备）成为控制终端
此标志防止pathname成为控制终端，如果正在打开的文件不是终端设备，此标志无效
O_NOFOLLOW	对符号链接不予解引用
通常，如果pathname是符号链接，open()函数将对pathname参数进行解引用。一旦指定了O_NOFOLLOW标志，且pathname是符号链接，则open()函数调用失败， errno=ELOOP, <fcntl.h>, _GNU_SOURCE
O_TRUNC		截断已有文件，使其长度为0
------------------三------------------------------
O_APPEND	总是在文件尾部添加数据
O_ASYNC		当IO操作可行时，产生信号（signal）通知进程
这个只对特别类型的文件有效，比如终端，FIFOS,socket,在linux中open()指定O_ASYNC没有任何实际效果，需要用fcntl()F_SETFL操作来设置O_ASYNC
O_DSYNC		提供同步的IO数据完整性
O_NONBLOCK	以非阻塞方式打开
O_SYNC		以同步方式写入文件
------------------------------------------------
第一部分在调用open()时，只能指定其中一个
第二部分，这些标志不能检索，也无法修改
第三部分，使用fcntl()的F_GETFL和F_SETFL操作可以分别检索和修改此类标志。有时干脆称之为文件状态标志

open()函数的错误
EACCESS,文件权限不允许调用进程以flags参数指定的方式打开文件。无法访问文件，其可能的原因有，目录权限的限制，文件不存在并且也无法创建该文件
EISDIR，所指定的文件属于目录，而调用者系统打开该文件进行写操作。不予许这种做法（另一方面在某些场景下，打开目录并进行读操作是有必要的）
EMFILE，进程已打开的文件描述符数量达到了进程资源限制所设置的上线
ENFILE，文件打开数量已达到系统允许的上线
ENOENT，要么文件不存在且未指定O_CREAT标志，要么你指定了O_CREAT标志，但pathname所指定路径之一不存在，或者pathname参数为符号链接，而该链接指向的文件不存在
EROFS，所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件
ETXTBSY，所指定的文件为可指定文件（程序），且正在运行，系统不允许修改正在运行的程序（比如以写方式打开文件），必须先终止程序运行，然后才可以修改可执行文件

改变文件偏移量lseek()
SEEK_SET
SEEK_CUR
SEEK_END
文件空洞
如果程序的文件偏移量已经跨越了文件结尾，然后在执行io操作，read()调用将返回0，表示文件结尾，有点令人惊讶的是，write()函数可以在文件结尾后的任意位置写入数据。
从文件结尾后到写入数据间的这段空间被称为文件空洞，从编程角度上来看,文件空洞中是存在字节的，读取空洞将返回以0（空字节）填充的缓存区
然而，文件空洞是不占用磁盘空间的，知道后续某个时间点，在文件空洞中写入数据，文件系统才会位置分配磁盘空间。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块来比
。稀疏填充的文件会占用较少的磁盘空间。核心转储文件（core dump）是包含空洞文件的常见例子
如果空洞的边界落在块内，而非签好落在块边界上，则会分配一二完整的块来存储数据，块中与空洞相关的部分则以空字节填充



