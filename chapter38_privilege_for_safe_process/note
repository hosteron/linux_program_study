以最小权限操作
uid_t orig_euid;
orig_euid = geteuid();
seteuid(getuid());
//do unprivileged work
seteuid(orig_euid);
//do privileged work

一个程序可以使用setrlimit()将RLIMIT_CORE资源限制设置为0来防止核心dump文件的创建,在默认情况下,linux不允许set-user-ID程序在收到信号时执行一个核心dump
确定进程的边界
使用能力和securebits标记可以创建只拥有有限的一组权限但无需属于root的进程(即进程的所有用户ID都不为零).这样的进程无法使用exec()来重新获取所有能力
考虑使用一个chroot监牢
 在特定情况下一项有用的安全技术是建立一个chroot监牢来限制程序能够访问的一组目录和文件

小心信号和竞争条件
	1.一个set-user-ID程序确定与其运行环境有关的一些信息
	2.用户需要停止运行程序的进程和修改运行时环境的细节,这样的变更可能包括修改文件的权限,改变符号链接的目标以及删除程序所依赖的文件
	3.用户使用SIGCONT信号恢复进程.这时程序会假设原先的运行时环境没有发生变化并继续执行,但其实运行时环境已经发生变化,因此在这种假设可能会破坏系统的安全性

执行文件操作和文件IO的缺陷
如果一个特权进程需要创建一个文件,那么必须要小心处理那个文件的所有权和权限以确保文件不存在被恶意操作攻击的风险点,不管这个风险点有多小.因此需要遵循下列指南:
	1.需要将进程umask值设置为一个确保进程永远无法创建公共可写的文件的值,否则恶意用户就能修改这些文件了
	2.由于文件的所有权是根据创建进程的有效用户ID来确定的,因此可能需要使用seteuid()()或setreuid()来临时地修改进程的身份信息以确保新创建的文件不会属于错误的用户,由于文件的组所有全可能会根据
	进程的有效组ID,因此类似的规则也同样适用于set-group-ID程序
	3.如果一个set-user-ID-root程序必须要创建一个一开始由其自己拥有但最终由另一个用户拥有的文件,那么所创建的文件在一开始应该不对其他用户开放写权限,这可以通过open()传入一个适当的mode参数
	或在调用open()前设置进程的umask.之后程序可以使用fchown()修改文件的所有权,然后根据需要使用fchmod()修改文件的权限.这里的关键点是set-user-ID程序应该确保它永远不会创建一个由程序所有者拥有
	但允许其他用户写入(即使这项权限只开放了一个瞬间)的文件
	4.在打开的文件描述符上检查文件的特性(如在open()之后调用fstat()),而不是检查与一个路径名相关联的特性后再打开文件(如在stat()之后调用open()),后一种方法存在使用时间和检查时间的问题
	5.如果一个程序必须要确保它自己是文件的创建者,那么在调用open()时应该使用O_EXCL标记
	6.特权进程应该避免创建或依赖像/tmp这样的公共可写的目录,因为这样程序就容易受到那些试图创建文件名和特权程序预期一致的非授权文件的恶意攻击.一个必须要在某个公共可写的目录中创建文件的程序应该
	至少要使用诸如mkstemp()之类函数确保这个文件的文件名不可预知

