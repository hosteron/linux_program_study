2.1
 内核的职责
  进程的调度
  内存管理： 进程与进程之间，进程与内核之间隔离，因此一个进程无法读取或修改内核或者其他进程的内存内容
       	     只需要将进程的一部分保持在内存中，这不但降低了每个进程对内存的需求量，而且还能在RAM中同时加载更多进程，这也大幅提升了如下事件的发生概率，在任何时刻，CPU都有至少一个进程可以执行，从而使得对CPU资源的使用更加充分
  提供了文件系统
  创建和终止进程
  对设备的访问
  联网
  提供系统调用应用编程接口API
  虚拟私有计算机
 
 内核态和用户态
  执行硬件指令可使CPU在两种状态间来回切换，与之对应的，可将虚拟内存区域划分未用户空间或者内核空间部分，在用户态下运行时，CPU只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常，当运行于核心态时，CPU既能访问用户空间内存，也能访问内核空间内存
  仅当处理器在核心态运行时，才能执行某些特定操作
    执行宕机，访问内存管理硬件，以及设备I/O操作的初始化

 以进程及内核视角检视系统

 shell

 用户和组
  系统会对每个用户的身份做唯一标识，用户可以隶属于多个组
  用户
   系统的每个用户都有唯一的登录名和一直对应的整数型用户ID（UID）。系统密码文件/etc/passwd为每个用户都定义有一行记录。除了以上两项信息。还包括如下信息：
   组ID：用户所属第一组的整数型组ID
   主目录
   登录shell
  组
   每个用户组都对应着系统组文件/etc/group中的一行记录，该记录包含如下信息
   组名
   组ID
   用户列表：隶属于该组的用户登录名列表，以逗号分割
  超级用户
 
 文件类型
  普通文件，设备，管道，嵌套字，目录以及符号链接

  路径和链接
   目录是一种特殊类型的文件，内容采用表格形式，数据项包括文件名以及对应文件的引用
  符号链接
   是给文件起了一个“别名”。在目录列表中，普通链接的内容为“文件名+指针”的一条记录，而符号链接则是经过特殊标记的文件，内容包含了另一个文件的名称
   换言之，一个符号链接对应着目录中内容为“文件名+指针”的一条记录，指针指向的文件内容为另一个文件名的字符串。
   多数情况下，只要系统调用用到了路径名，内核会自动接触该路径中的符号链接的引用，以符号链接所指向的文件名来替换符号链接
   为了应对可能出现的循环引用，内核对解除引用的次数做了限制
   如果符号链接指向的文件并不存在，那么可将该链接视为空链接（dangling link）
   通常人们会用硬链接或软链接这样的术语来指代正常链接和符号链接
  文件名
  在大多数的linux系统上，文件名最长可达255个字符，文件名可以包括除/和空字符外的所有字符，但是，只建议使用字母，数字，点，下划线以及连字符；SUSv3 将这65个字符集合[-._a-zA-Z0-9]称为可移植文件名字符集
  路径名
   绝对路劲
   相对路径

  当前工作目录
   进程当前工作目录继承其父进程。对登录shell来说，其初始当前目录，是依据密码文件中该用户记录的主目录字段来设置,用cd 命令可以改变shell的当前工作目录
  文件的所有权和权限
   每个文件都有一个与之相关的用户ID和组ID，分别定义了文件的属主和属组。系统根据文件的所有权来判定用户对文件的访问权限
   为了访问文件，系统把用户分为3类：文件的属主，与文件组ID相匹配的属组成员用户以及其他用户
    也可针对目录进行上述权限 设置；写权限允许目录内容进行更改（比如。添加，修改或者删除文件名），执行（有时也称为搜索）权限允许对目录中的文件进行访问（但需要受文件自身访问权限的约束），读权限允许列出目录内容（即该目录下的文件名）
 
 文件I/O模型
 文件描述符
 程序
 过滤器
  从stdin读取输入，加以转换，再将转换后的数据输出到stdout,常常将用户上述行为的程序称为过滤器，cat ,grep, tr ,sort , wc ,sed, awk都在此列
 命令行参数
 进程
  进程是正在执行的程序的实例，执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账数据结构，以记录与进程有关的各种信息（比如，进程ID，用户ID，组ID以及终止状态等）
 进程的内存分布
 逻辑上将一个进程划分为一下几个部分
  文本
  数据
  堆
  栈
 创建进程和执行程序
  调用fork来创建一个新进程，调用fork进程被称为父进程。内核通过对父进程的复制来创建子进程。子进程从父进程继承数据段，栈段以及堆段的副本后，可以修改这些内容，不会印象父进程的原版内容，在内存中被标记为只读的程序文本段则由父，子进程共享，然后子进程要么去执行和父进程共享代码的另一组不同的函数，或者更为常见的情况是使用系统调用execve()去加载并执行一个全新的程序
 进程ID和父进程ID
 进程的终止和终止状态
  进程使用_exit()系统调用（或相关的exit()库函数），请求退出
  向进程传递信号，将其“杀死”
  无论用何种方式退出，进程都会生成“终止状态”，一个非负小整数，可供父进程wait()系统调用检测。
  在调用_exit()系统调用情况下，进程会指明自己的终止状态。
  若由信号来"杀死"进程，则会根据导致进程“死亡”的信号类型来设置进程的终止状态。（有时会将传递进_exit()的参数称为进程的“退出状态”），以示与终止状态有所不同，后者要么指传递给_exit()的参数值，要么表示“杀死”进程的信号
  0表示“功成身退”，非0表示有错误发生
  大多数shell会将前一个执行程序的终止状态保存在shell变量$?中
 
 进程的用户和组标识符
  每个进程都有一组与之相关的用户ID和组ID
  1.真实用户ID和组ID
  2.有效用户ID和组ID：进程在访问受保护资源来确定访问权限
  3.补充组ID
 特权进程
 能力
 init进程
 守护进程： "长生不老"， 守护进程在后台运行，且无控制终端供其读取和写入数据，比如,syslogd,httpd
 环境列表
 资源限制

 内存映射
  文件映射
  匿名映射，其映射页面的内容会被初始化为0

 静态库和共享库
  静态库
   对于所需库内的各自模块，采用静态链接方式生成的程序都存在一个副本。这会引起诸多不变
    1.在不同的执行文件中，可能存在相同目标代码的副本，这对磁盘空间的浪费。
    2.调用同一个库函数的程序，若以静态链接的方式生成，且又同时加以执行，这会造成内存浪费，因为每个程序所调用的函数都各自有一份副本驻留子内存中
    3.如果对库函数进行了修改，需要重新编译，生成新的静态库，而所有需要调用该函数“更新版”的应用，都必须与新生成的静态库重新链接
  共享库
   如果将程序链接到共享库，那么连接器就不会把库中的目标模块复制到可执行文件中，而是在可执行文件中协议一条记录，以表明可执行文件在运行时需要使用该共享库。一旦运行时将可执行文件载入到内存，一款名为“动态连接器”的程序会确保将可执行文件所需的动态库找到，并载入内存，随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中的相应函数定义关联起来，在运行时，共享库在内存中只需要保存一份，且可供所有运行中的程序使用
   经过编译处理的函数仅在共享库中保存一份，从而节约了磁盘空间
   这一设计还确保各类程序及时使用到函数最新的版本，只需将带有函数新定义体的共享库重新加以编译即可，程序会在下次执行时自动使用新函数

 进程间通信及同步
  1.信号
  2.管道
  3.嵌套字
  4.文件锁定
  5.消息队列
  6.信号量
  7.共享内存
 
 信号
  内核，其他进程或者进程本省均可向进程发送信息
   1.用户进入中断字符（ctl + c）
   2.进程的子进程之一终止
   3.有进程设定的定时器到期
   4.进程尝试访问无效的内存地址
 线程

 进程组和shell任务控制
 
 回话，控制终端和控制进程
 伪终端

 时间和日期
  1.真实时间
  2.进程时间：time 命令会显示出真实时间，系统cpu时间，以及执行管道中的多个进程而花费的用户cpu时间

 客户端/服务器架构
 服务器可以提供各种服务
  1.提供对数据库或者其他共享信息资源的访问
  2.提供对远程文件的跨网访问
  3.对某些商业逻辑进行封装
  4.提供对共享硬件资源的访问（比如，打印机）
  5.提供WWW服务
　将某项服务封装于单独的服务器应用中，这一做法原因有很多。举例如下
　 1.效率，较之于在本地的每台计算上提供相同资源，在服务器应用管理之下提供资源的一份实例，则要节约很多
　 2.控制，协调和安全：由于资源的统一存放，服务器既可以协调对资源的访问，还可以保护资源的安全，另其只对特定的客户端开发
　 3.在异构环境中运行：在网络中，客户端和服务器应用所运行的硬件架构和操作系统可以不同
  
　实时性
　/proc 文件系统
 
