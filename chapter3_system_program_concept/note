3.1系统调用
系统调用时经历很多步骤：
1.应用程序通过调用Ｃ语言函数库中的外壳（wrapper）函数，来发起系统调用
2.对系统调用中断处理例程来说，外壳函数必须保证所有系统调用参数可用。通过堆栈，这些参数传入外壳函数，但内核却希望将这些参数植入特定寄存器。因此，外壳函数会将上述参数复制到寄存器中
3.由于所有系统调用进入内核的方式相同，内核需要设法区分每个系统调用。为此，外壳函数会将系统调用编号复制到一个特定的寄存器中（%eax）
4.外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到核心态，并执行系统中0x80的中断矢量所指向的代码
  较新的x86-32实现了sysenter,来替代int  0x80
5.为响应中断0x80，内核会调用system_call()例程，（位于汇编文件arch/i386/entry.S）来处理这次中断，具体如下：
a） 在内核栈中保存寄存器值
b）审核系统调用编号的有效性
c） 检查相应传入参数有效性，执行相关任务，和用户空间传递数据，最后，该服务例程会将结果状态返回给system_call例程
d）从内核栈中恢复各寄存器的值，并将系统调用返回值置于栈中
e）返回至外壳函数，同时将处理器切换到用户态
6.若系统调用服务例程的返回值表明调用有错，外壳函数会使用该值来设置全局变量errno,然后，外壳函数会返回到调用程序，并同时返回一个整数值，以表明系统调用是否成功
  
3.3 标准C语言函数库：gnu c 语言函数库
确定系统的glibc版本
直接运行$/lib/libc.so.6
某些linux发行版本中gnu c语言函数库的路径名并非“/lib/libc.so.6”,通过下面命令来找出在哪里
$ ldd a.out | grep libc 
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdd31805000)

应用程序通过测试常亮和调用库函数两种方法，来确定系统所安装的glibc版本。从版本2.0开始，glibc定义了两个常量，__GLIBC__和__GLIBC_MINOR__;
在安装有glibc2.12版本的系统上，以上两个常量的值分别是2和12；
然后如果程序在A系统上编译，却在B系统上运行，这两个常量作用不大，为应对这种可能，程序可以调用函数gnu_get_libc_version(),来确定运行时的glibc版本
