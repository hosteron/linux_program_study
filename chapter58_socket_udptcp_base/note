	internet(小写的i),会将不同的计算机网络链接起来并允许位于网络中的主机互相之间进行通信
    子网，用来指组成因特网的其中一个网络
    Internet(大写的I)被用来指定将全球成千上万的计算机连接起来的TCP/IP互联网

	一台路由器拥有多个网络接口，每个接口都链接到一个子网络上．更通用的术语＂多宿主机＂用来指拥有多个网络接口的任意主机－－－不必是一台路由器．一个多宿主机的各个接口上的网络地址是不同的（即其链接的各个子网的地址是不同的）
	tcp/ip协议套件是一个分层联网协议，它包括因特网协议（ＩＰ）和位于其上层的各个协议层．协议栈（实现这些层的代码）
	地址解析协议（ＡＲＰ）关注的是如何将因特网地址映射到硬件（如以太网）地址
	因特网控制消息协议（ICMP）用来在网络中传输错误和控制信息
	（ping, traceroute）程序使用的是ICMP协议，人们通常使用ping来检查一台特定的主机是否存活以及是否在TCP/IP网络中可见
	　　使用traceroute来跟踪一个ＩＰ包在网络中的传输路径
	主机和路由器使用因特网组管理协议（IGMP）来支持IP数据报的多播
	应用层
	表示层
	会话层
	传输层 　　－－－＞udp, tcp
	网络层   -----> ip
	数据链路层
	物理层
	
	封装
	封装是分层联网协议中的一个重要的原则．
		其中的关键概念是底层会将从高层向底层传递的信息（如应用程序数据，tcp段，IP数据报）当成不透明的数据来处理．换句话说，底层不会尝试对高层发送过来的信息进行解析，而只会将这些信息放到底层所使用包中并在将这个包向下传递到低层之前添加自身这一层的头信息
			当数据从低层传递到高层时会进行一个逆向的解包过程
	数据链路层可能会进行错误检测，重传以及流量控制．一些数据链路层还可能将大的网络包分割成多个帧并在接受者端对这些帧进行重组，其还会包含一个头，如头中可能包含了目标地址和帧的大小
	
	从应用程序编程的角度来讲通常可以忽略数据链路层，因为所有通信细节都是由驱动和硬件来处理的
	
	对于有关ＩＰ的讨论来讲，数据链路层中比较重要的一个特点是最大传输单元(MTU).数据链路层的MTU是该层所能传输的帧大小的上限，不同数据链路层的MTU是不同的
	
	命令netstat -i 会列出系统中的网络接口，包括其MTU
	
网络层：ＩＰ
	位于数据链路层之上的是网络层，它关注的是如何将包（数据）从源主机发送到目标主机．这一层执行了很多任务，包括以下几个
	１．将数据分解成足够小的片段以便数据链路层进行传输（如有必要的话）
	２．在因特网上路由数据
	３．为传输层提供服务

ＩＰ传输数据报
	ＩＰ以数据报（包）的形式来传输数据．在两个主机之间的每一个数据报都是在网络上独立传输的，它们经过的路劲可能会不同．一个ＩＰ数据报包含一个头，其大小范围为２０字节到６０字节．这个头中包含了目标主机的地址，这样就可以在网络上将这个数据报
	路由到目标地址了．此外，它还包含了包的源地址，这样接受主机就知道数据报的源头了
	
	一个ＩＰ实现可能会给它锁支持的数据报的大小设定一个上限．所有ＩＰ实现必须做到数据报的大小至少与规定的ＩＰ最小重组缓冲区大小一样大 ．在IPv4中，这个限制是576字节，在ＩＰｖ６中这个限制是１５００字节，（其表示数据大小上限有一个最小值限制，设定的上限最小不能小于这个值）

ＩＰ是无链接和不可靠的
	它尽最大可能将数据从发送者传输给接受者，但并不保证包到达的顺序会与它们被传出的顺序一致，也不保证包是否重复，甚至都不保证包是否会达到接受者．ＩＰ也没有提供错误恢复（头信息错误的包会被静默的丢弃）
	可靠性是通过使用一个可靠的传输层协议（如ｔｃｐ）或应用程序本身来保证的

ＩＰ可能会对数据报进行分段
	ＩＰｖ４数据报的最大大小是６５５３５字节．在默认情况下，IPv6允许一个数据报的最大大小是６５５７５字节（４０字节用于存放头信息，６５５３５字节用来存储数据），并且为更大的数据报（所谓的jumbograms）提供了一个选项
	大多数数据链路层会为数据帧的大小设定一个上限(MTU).如在常见的以太网架构中这个上限值是１５００字节（比一个ＩＰ数据报的最大大小要小很多）．ＩＰ还定义了路径MTU的概念，它是源主机到目的主机之间路由上的所有数据链路层的最小MTU(在实践中，以太网MTU通常是路径中最小的MTU)
	当一个ＩＰ数据报的大小大于MTU时，ＩＰ会将数据报分段（分解）成一个个大小合适在网络上传输的单元．这些分段在达到最终目的地之后会被重组成原始的数据报
	
	ＩＰ分段的发生对于高层协议层是透明的，并且一般来讲也并不希望发生这种事情．这里的问题在于由于ＩＰ并不进行重传并且所有分段都达到目的地之后才能对数据报进行组装，因此如果其中一些分段丢失或包含传输错误的话会导致整个数据报不可用
	在一些情况下，这会导致极高的数据丢失率（适用于不进行重传的高层协议，如果ＵＤＰ）或降低传输速率（适用于进行重传的高层协议，如tcp）.现代tcp实现采用了一些算法（路径MTU发现）来确定主机之间的一条路劲MTU，并根据该值对传递给ＩＰ的数据进行分解，这样ＩＰ就不会碰到需要传输大小超过MTU的数据报的情况了
		ＵＤＰ并没有提供这种机制，后面会讲到ＵＤＰ应用程序如何处理IP分段的情况

ＩＰ地址
	一个ＩＰ地址包含两个部分：
		１．网络ＩＤ，它指定了主机所属的网络
		２．主机ＩＤ，它标识出了位于网络中的主机
		网络地址：		网络ＩＤ			｜		主机ＩＤ
		网络掩码：		全１				｜		全０
	ＩＰｖ４地址
		一个IPv4地址包含３２位
		当一个组织为其主机申请一组IPv4地址时，它会收到一个32位的网络地址以及一个对应的３２位的网络掩码
	２０４．１５２．１８９．０／２４
	这里的／２４表示分配的地址的网络ＩＤ由最左边的２４位构成，剩余的８位用于指定主机ＩＤ，或者在这种情况下也可以说网络掩码的点分１０进制标记为２５５．２５５．２５５．０
	拥有这个地址的组织可以将２５４个唯一的因特网地址分配给其计算机－－－２０４．１５２．１８９．１到２０４．１５２．１８９．２５４
		有两个地址是无法分配给计算机的，其中一个地址的主机ＩＤ的位都是０，它用来标识网络本身，另一个是主机ＩＤ都为１的－－在本例中是２０４．１５２．１８９．２５５－－－它是子网广播地址
	一些ＩＰｖ４地址拥有特殊的含义．
		１２７．０．０．１一般被定义为回环地址，它通常会被分配给主机名localhost（网络127.0.0.0/8中的所有地址都可以被指定为IPv4回环地址，单通常会选择127.0.0.1）发送到这个地址的数据报实际上不会发送达到网络，它会自动回环变成发送主机的输入
			使用这个地址可以便捷地在同一主机上测试客户端和服务器程序．
				在ｃ程序中定义了整数常量INADDR_LOOPBACK来表示这个程序
		常量INADDR_ANY就是所谓的ipv4通配地址
			通配IP地址对于将internet domain　ｓｏｃｋｅｔ绑定到多宿主机上的应用程序来将是比较有用的
			SUSv3并没有为INADDR_ANY规定一个特定的值，但大多数实现将其定义成了0.0.0.0（全是０）
			
		一般来讲，IPv4地址是划分子网的．划分子网将一个IPV4地址的主机ＩＤ部分分成两个部分：一个子网ＩＤ一个主机ＩＤ＝＝＞如何划分主机ＩＤ的位完全是由网络管理员来决定的
		网络地址：		网络ＩＤ			｜	子网ＩＤ		｜	主机ＩＤ
		子网掩码：	全１									｜	全０
			子网划分的原理在于一个组织通常不会将其所有主机接到单个网络中，相反，组织可能会开启一个子网（一个＂内部互联网＂），每个子网使用网络ＩＤ和子网ＩＤ组合起来标识．这种组合通常被称为扩展网络ＩＤ
				在一个子网中，子网掩码所扮演的角色与之前描述的网络掩码的角色是一样的，并且可以使用类似的标记法来标识分配给一个特定子网的地址范围
					假设分配到的网络ＩＤ是204.152.189.0/24,这样可以通过将主机ＩＤ的８为中的４为划分成子网ＩＤ并将剩余的４位划分成主机ＩＤ来对地址范围划分子网
	
	ＩＰｖ６地址
		其用的是１２８位来表示，其中地址中的前面一些位是一个格式前缀，表示地址类型．
		ipv6地址通常被书写成一系列用冒号隔开的１６位的１６进制数字：如下所示
		F000:0:0:0:0:0:A:1
		IPv6地址通常包含一个０序列，并且为了标记方便，可以使用两个分号（：：）来表示这种序列，只能出现一个双冒号标记，出现多次的话会造成混淆
		F000::A:1
		IPv6也想IPv4地址那样提供了回环地址（１２７个0加上一个１，即::1）和通配地址（所有都是０，0::0或::）
		
			IPv4映射的IPv6地址的格式
			|		全０			｜	FFFF	|	IPv4地址		｜
				80位					16位			32位
	在书写IPv4映射的IPv6地址时，地址的IPv4部分，会被书写成IPv4的点分１０进制标记．因此204.152.189.116等价的IPv4映射的IPv6地址是::FFFF:204.152.189.116

传输层
	众所周知的，注册的以及特权端口号
		有些众所周知的端口号已经被永久地分配给特定的应用程序了（也成为服务）ssh-> 22 , HTTP->80,众所周知的端口号位于0~1023之间
		IANA注册的端口范围是1024~41951（不是所有位于这个范围内的端口被注册了）
		０～１０２３端口也是特权端口，也就意味着只有特权进程能够绑定到这些端口上，从而防止普通用户通过实现恶意程序（如伪造ssh）来获取密码
		尽管端口号相同的tcp和udp端口是不同的实体，但同一个众所周知的端口号通常会同时被分配给基于TCP和ＵＤＰ服务，即使该服务通常只提供了其中一种协议服务．这种惯例避免了端口号在两个协议中产生混淆的情况
	临时端口
		客户端－－一般并不关心它所使用的端口号，但分配给一个端口对于传输层协议标识通信端点来讲是必要的
			tcp,udp在将socket绑定到端口０上时也会分配一个临时端口号
		在linux中，/proc/sys/net/ipv4/ip_local_port_range可以来定义这个临时端口的范围
		
		cat /proc/sys/net/ipv4/ip_local_port_range
		32768	60999

DUP:
	其仅仅在ＩＰ之上添加了两个特性：端口号和一个进行检测传输数据错误的数据校验和，其也是无连接的，和ＩＰ一样．由于其并没有在IP之上增加可靠性，因此UDP是不可靠的

	选择一个UDP数据报大小以避免ＩＰ分段
		以及ＵＤＰ的应用程序通常不会知道源主机和目的主机之间的路劲的MTU．一般来讲基于ＵＤＰ的应用程序会采用保守的方法来避免ＩＰ分段，即确保传输的ＩＰ数据的大小小于IPv4的组装缓冲区大小的最小值576字节．（这个值很可能是小于路径MTU的）
			在这个576字节中有８个字节是存放UDP头的，另外最少需要使用２０个字节来存放IP头，剩下的５４８字节存放UDP数据本身，在实践中，采用512
TCP:
	tcp在两个端点（即应用程序）之间提供了可靠的，面向链接的，双向字节流通信通道
	建立链接
	将数据打包成段
		数据会被分解成段，每个一个段都包含一个检验和，从而能够检测出端到端的传输错误．每一个段使用单个ＩＰ数据报来传输
	确认，重传以及超时
		当一个TCP无错误到达目的地址，接受ＴＣＰ会想发送者发送一个确认，通知它数据发送传递成功了．如果段在到达时存在错误，会被丢弃，确认信息也不会被发送．为处理段永远不达到或被丢弃的情况，发送者在每发送一个段会开启一个定时器．如果在定时器超时之前没有收到确认，就会重传这个段
		由于所使用的网络以及当前的流量负载会影响传输一个段和确认所需要的时间，tcp采用了一个算法来动态地调整重传超时时间(RTO)的大小
		接收tcp可能不会立即发送确认，而是会等待几毫秒来观察一下是否可以将确认塞进接受者返回给发送者的响应中（每个tcp段都包含一个确认字段，这样就能将确认塞进tcp段中了）这项被称为延迟ACK的技术的目的是能少发送一个tcp段，从而降低网络中包的数量以及降低发送和接收主机的负载
	排序
		在tcp链接上传输的每个字节都会分配到一个逻辑号．这个数字指出了该字节在这个连接的数据流中所处的位置（这个连接中的两个流各自都有自己的序号计数系统）
		作用：
			１．在目的地组装
			2.由接收者返回给发送者的确认消息可以使用序号来标识处收到哪个tcp分段
			3.接收者可以使用序号来移除重复的分段
		一个流的初始序号不是从0开始的,相反,它是通过一个算法来生成的.序号是一个32位的值,当到达最大值时会回到0
	流量控制
		tcp流量控制算法采用了所谓滑动窗口算法,它允许包含总共N字节(提供的窗口大小)的未确认段同时在发送者和接收者之间传输.如果接收tcp的进入数据缓冲区完全被充满了,那么窗口就会关闭,发送tcp就会停止传输数据
		接收者可以使用SO_RCVBUF socket选项来覆盖进入数据缓冲区的默认大小
	拥塞控制:慢启动和拥塞避免算法
		tcp的拥塞控制算法在下列场景中是比较重要的
		1.在建立连接之后
		2.当拥塞被检测到时
	慢启动算法会使发送tcp在一开始的时候以低速度传输分段,但同时允许它以指数级速度提高其速率,只要这些分段都得到接收tcp的确认
	
	慢启动和拥塞避免算法组合起来使得发送者可以快速地将传输速度提升至网络的可用容量,并且不会冲出该容量.这些算法的作用是允许数据传输快速地到达一个平衡状态
	
	
