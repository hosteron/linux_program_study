每个进程拥有3个相关能力集-术语:许可的,有效的,可继承的
同样,每个文件也可以拥有3个相关的能力集,其名称与进程的能力名称一样

进程能力:
内核为每个进程维护了3个能力(实现为掩码),每个能力集中都包含了表39-1中列出的已经启用零个或多个能力
1.许可的
	这些是一个进程能够使用的能力.许可的集合是能够被添加进有效的和可继承的集合中的能力受限超集.如果一个进程从其许可集中删除了一个能力,那么将永远也无法在重新获取该能力(除非它执行了一个再次授予能力的程序)
2.有效的
	内核会使用这些能力来对进程执行权限检查.只有进程在其许可集中维护着一个能力,那么进程才能通过从有效集中删除这个能力来临时禁用这个能力,之后再将该能力还原到这个集合中
3.可继承的
	当这个进程执行一个程序时可以将这些权限带入许可集合中

可以使用getpcap程序以更易阅读的格式显示一个进程的能力

通过fork()创建的子进程会继承父进程的能力集副本

实际上,能力是一个线程级的特性,进程中的每个线程的能力都可以单独进行调整
在/proc/PID/task/TID/status文件中可以查看一个多线程进程中某个具体线程的能力
/proc/PID/status显示了主线程的能力

文件能力
许可的
	在exec()调用中可以将这组能力添加到进程的许可集中,不管进程的既有能力是什么
有效的
	这个只有一位.如果被启用了,那么在exec()调用中,进程的新许可集中启用的能力在进程的新有效集中也会被启用.如果文件有效位被禁用了,那么在exec()执行完之后,进程的新有效集在一开始是空的
可继承的
	这个集合将与进程的可继承集去掩码来确定在执行exec()之后进程的许可集中启用的能力集

getcap, setcap能力

现代能力实现
	1.对于每个特权操作,内核应该检查进程是否拥有相应的能力,而不是检查有效用户ID是否为0
	2.内核必须要提供允许获取和修改进程能力的系统调用
	3.内核必须要支持将能力附加给可执行文件的概念,这样当文件被执行时进程会获取相应的能力

在exec()中转变进程能力
在exec()执行期间,内核根据进程当前的能力以及被执行的文件的能力集来设置进程新能力
P`(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)
P`(effective) = F(effective) ? P`(permitted):0
P`(inheritable) = P(inheritable)
cap_bset:表示能力边界集的取值

init进程在启动时会使用一个包含所有能力的能力边界值    ,其也是一个线程属性
CapInh: 0000000000000000
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff  边界值

保持root语义
1.如果执行了一个set-user-ID-root程序或调用exec()的进程的真实或有效用户ID为0,那么文件的可继承和许可集被定义为包含所有能力
2.如果执行了一个set-user-ID-root程序或调用exec()的进程的有效用户ID为0,那么文件有效位被定义成设置状态

securebits标志和能力配合使用,其也是一个线程属性

发现程序所需要的能力
1.strace 检查哪个系统调用的错误号是EPERM,这个可能不准
2.使用一个内核探针在内核被要就执行能力检查时产生监控输出

