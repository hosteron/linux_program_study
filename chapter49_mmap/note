mmap()系统调用在调用进程虚拟地址空间中创建一个新内存映射.映射分为两种
	1.文件映射:将一个文件的一部分直接映射到调用进程的虚拟内存中.一旦一个文件被映射之后就可以通过在相应的内存区域中操作字节来访问文件内容了.映射的分页会在需要的时候从文件中(自动)加载.这种映射也被称为基于文件的映射或内存映射文件
	2.匿名映射:一个匿名映射没有对应的文件.相反,这种映射的分页会被初始化为0
	另一中看待匿名映射的角度(并且也接近事实)是把它看成是一个内容总是被初始化为0的虚拟文件的映射

一个进程的映射中的内存可以与其他进程中的映射共享（即各个进程的页表条目指向RAM中相同的分页）．这种行为会在两种情况下发生
	１．当两个进程映射了一个文件的同一个区域时它们会共享物理内存的相同分页
	２．通过fork()创建的子进程会继承其父进程的映射的副本，并且这些映射所引用的物理内存分页与父进程中相应映射所引用的分页相同
	
当两个或更多个进程共享相同分页时，每个进程都有可能会看到其他进程对分页内容做出的变更，当然这取决于映射是私有还是共享的
	１．私有映射(MAP_PRIVATE):在映射内容上发生的变更对其他进程不可见，对于文件映射来讲，变更将不会在底层文件上进行．尽管一个私有映射的分页在上面介绍的情况中初始时是共享的，但对映射内容所做出的变更对各个进程来讲则是私有的．内核使用了写时复制技术来完成这个任务
	这意味着当一个进程试图修改一个分页的内容时，内核首先会为该进程创建一个新分页并将需修改的分页中的内容复制到新分页中（以及调整进程的页表）．正因为这个原因MAP_PRIVATE映射有时候也被称为私有，写时复制映射
	２．共享映射（MAP_SHARED）：在映射内容上发生的变更对所有共享同一个映射的其他进程都可见，对于文件映射来讲，变更将会发生在底层文件上

各种内存映射的用途
	变更的可见性					映射类型
						文件						匿名
	私有			根据文件内容初始化					内存分配
	共享			内存映射IO;进程间共享内存(IPC)		进程间共享内存(IPC)

这四种不同的内存映射的创建和使用方式如下:
	1.私有文件映射:
		映射的内容被初始化为一个文件区域的内容.多个映射同一个文件的进程初始时会共享相同的内存物理分页,但系统使用写时复制技术使得一个进程对映射所做出的变更对其他进程不可见.这种映射的主要用途是使用一个文件的内容来初始化一块内容区域.
			一些常见的例子包括根据二进制可执行文件或共享库文件的相应部分来初始化一个进程的文本和数据段
	2.私有匿名映射:
		每次调用mmap()创建一个私有匿名映射时都会产生一个新映射,该映射与同一(或不同)进程创建的其他匿名映射是是不同的(即不会共享物理分页).尽管子进程会继承其父进程的映射,但写时复制语义确保在fork()之后父进程和子进程不会看到其他进程对映射所做出的变更.
		私有匿名映射的主要用途是为一个进程分配(用零填充)内存(如在分配大块内容时malloc()会为此使用mmap())
	3.共享文件映射:
		所有映射一个文件的同一个区域的进程会共享同样的内存物理分页,这些分页的内容将被初始化为该文件区域.对映射内容的修改将直接在文件中进行.这种映射主要用途有两个:
			1.它允许内存映射IO.这表示一个文件会被加载到进程的虚拟内存中的一个区域中并且对该快内容的变更会自动被写入到这个文件中.因此,内润映射IO为使用read(),write()来执行文件IO这种做法提供了一种替代方案
			2.允许无关进程共享一块内容以便以一种类似于system V共享内存段的方式来执行(快速)IPC
	4.共享匿名映射:
		与私有匿名映射一样,每次调用mmap()创建一个共享匿名映射时都会产生一个新的,与任何其他映射不共享分页的截然不同的映射.这里的差别在于:
			映射的分页不会被写时复制.
			这意味着当一个子进程对映射内容所做出的变更会对其他进程可见.共享匿名映射允许以一种类似于system V共享内存段的方式来进行IPC.但只有相关进程之间才能这么做
	
	一个进程在执行exec()时映射会丢失,但通过fork()创建的子进程会继承映射,映射类型(MAP_PRIVATE 或MAP_SHARED)也会被继承

	mmap()的另一个用途是与POSIX共享内存对象一起使用,它允许无关进程在不创建关联磁盘文件(共享文件映射需要这样的文件)的情况下共享一块内存区域
	
创建一个映射mmap()
	#include <sys/mmap.h>
	void *mmap(void *addr, size_t length, int port, int flags, int fd, off_t offset);
		returns starting address of mapping  on success, or MAP_FAILED on error;
	addr 参数指定了映射被放置的虚拟地址.如果=NULL,那么内核会为映射选择一个适合的地址.这是创建映射首选的做法
		或者指定一个非NULL值,内核会在选择将映射放置在何处时将这个参数作为一个提示信息来处理.在实践中,内核至少会将指定的地址舍入到最近的一个分页边界处.
		不管采用何种方式,内核会选择一个不与既有映射冲突地址(如果在flags包含了MAP_FIXED,那么addr必须是分页对其的)
	成功时返回新映射的起始地址.发生错误时返回MAP_FAILED
	legnth->指定了映射的字节数,length会被向上提升为分页大小的下一个倍数
	port参数是一个位掩码,它指定了施加在映射上的保护信息
		值						描述
		PORT_NONE			区域无法访问
		PORT_READ			区域内容可读
		PORT_WRITE			区域内容可修改
		PORT_EXEC			区域内容可执行
	flags参数是一个控制映射操作各个方面的选项的位掩码
		MAP_PRIVATE	私有
		MAP_SHARED	共享
	fd,offset用于文件映射(匿名映射将忽略它们).fd参数是一个标识被映射的文件的文件描述符.offset参数指定了映射在文件中的起点,它必须是系统分页带下的倍数.要映射整个文件就需要将offset=0,并且length=文件的大小
	
	如果一个进程在访问一个内存区域违反了该区域上的保护位,那么内核会向该进程发送一个SIGSEGV信号
	标记为PORT_NONE的分页内存的一个用途是作为一个进程分配的内存区域的起始位置或结束位置的守护分页.如果进程意外地访问了其中一个被标记为PORT_NONE的分页,那么内核通过生成一个SIGSEGV信号来通知进程这样一个事实
	内存保护信息驻留在进程私有的虚拟内存表中.因此,不同的进程可能会使用不同的保护位来映射同一个内存区域
	使用mprotect()系统调用能够修改内存保护位
	
	SUSv3规定了offset参数必须与分页对齐,而addr参数在指定了MAP_FIXED的情况下也必须要与分页对齐.linux遵循了这些要求
	SUSv4放宽了这方面的要求
		1.一个实现可能会要求offset为系统分页大小的倍数
		2.如果指定了MAP_FIXED,那么一个实现就可能会要求addr是分页对齐的
		3.如果指定了MAP_FIXED并且addr为非零值,那么addr和offset除以系统分页代销所得的余数应该相等

解除映射区域:munmap()
	#include <sys/mman.h>
	int munmap(void *addr, size_t length)
		returns 0 on success, or -1 on error;
	addr参数是待解除映射的地址范围的起始地址,它必须是一个分页边界对齐
	length参数是一个非负整数,它指定了待解除映射区域的大小(字节数).范围为系统分页大小的下一个倍数的地址空间将会被解除映射
	一般来讲通常会解除整个映射
	或者解除一个映射中部分映射,这样原来的映射要么会收缩,要么被分成两个,这取决于在何处开始解除映射.还可以指定一个跨越多个映射的地址范围,这样的话所有在范围内的映射都会被解除
	如果在addr和length指定的地址范围中不存在映射,那么munmap()将不起到任何作用并返回0(表示成功)
	在解除映射期间,内核会删除进程持有的在指定地址范围内的所有内存锁.(内存锁是通过mlock()或mlockall()来建立)
	
	当一个进程终止或执行一个exec()之后进程中所有的映射都会被自动解除
	为了确保一个共享文件映射的内容会被写入到底层文件中,在使用munmap()解除一个映射之前需要使用msync()

文件映射
	在mmap()传入fd之后,就可以关闭fd了,而不会对mmap产生什么影响,不过有时也会保持其打开状态,可以参考54章
	打开文件描述符fd引用的文件必须要具备与port和flags参数匹配的权限.特别地,文件必须总是被打开以允许读取,并且在flags中指定了PORT_WRITE和MAP_SHARED,那么文件必须总是被打开以允许读取和写入
	offset必须是系统分页的大小的倍数


私有文件映射
	1.允许多个执行同一个程序或使用同一个共享库的进程共享同样的(只读的)文本段,它是从底层可执行文件或库文件的相应部分映射而来的
		尽管可执行文件的文本段通常是被保护成只允许读取和执行访问(PORT_READ|PORT_EXEC),但在被映射时仍然使用了MAP_PRIVATE而不是MAP_SHARED,这是因为调试器或自修改程序能够修改程序文本(在修改了内存上的保护信息之后),而这样的变更是不应该发生在底层文件上或影响其他进程的
	2.映射一个可执行文件或共享库的初始化数据段.这种映射会被处理成私有使得对映射数据段内容的变更不会发生在底层文件上
共享文件映射
	共享文件映射存在两个用途:内存映射IO和IPC
	
	内存映射IO具备两个潜在的优势:
		1.使用内存访问来取代read(),write()系统调用能够简化一些应用程序的逻辑
		2.在一些情况下,它能够比使用传统的IO系统调用执行IO这种做法提供更好的性能
	内存映射IO之所以能够带来性能上的优势的原因如下:
		1.正常的read()或write()需要两次传输;一次是在文件和内核高速缓冲区之间,另一次是在高速缓冲区和用户空间缓冲区之间.使用mmap()就无需第二次传输了.对于输入来讲,一旦内核将相应的文件块映射进内存之后用户进程就能够使用这些数据了.
			对于输出来讲,用户进程仅仅需要修改内存中的内容,然后可以依靠内核内存管理器来自动更新底层的文件
		2.除了节省了内核空间和用户空间之间的一次传输之后,mmap()还能够通过建扫所需使用的内存来提升性能.当使用read(),write()时,数据将被保存在两个缓冲区中:一个位于用户空间,另一个位于内核空间.当使用mmap()时,内核空间和用户空间会共享同一个缓冲区.
			此外,如果多个进程正在同一个文件上执行IO,那么它们通过使用mmap()就能够共享同一个内核缓冲区,从而又能节省内存的消耗
	内存映射IO所带来的性能优势在大型文件中执行重复随机访问时最有可能体现出来.如果循序地访问一个文件,并假设执行IO时使用的缓冲区大小足够大以至于能够避免执行大量的IO系统调用,那么与read(),write()系统调用相比,mmap()带来的性能上的提升就非常有限或者说根本就没有带来性能上的提升
		性能提升的幅度之所以非常有限的原因是不管使用何种技术,整个文件的内存在磁盘和内存之间只传输一次,效率的提高主要得益于减少了用户空间和内核空间之间的一次数据传输,并且与磁盘IO所需的时间相比,内存使用量的降低通常是可以忽略的
	内存映射IO也有一些缺点,对于小数据量IO来讲,内存映射IO的开销(即映射,分页故障,接触映射以及更新硬件内存管理单元的超前转换缓冲器)实际上要比简单的read(),write()大.此外,有些时候内核难以高效地处理可写入映射的回写(在这种情况下,使用msync()或sync_file_range()有助于提高效率)
	
	使用共享文件映射的IPC
		由于所有使用同样文件区域的共享映射的进程共享相同的内存物理分页,因此共享文件映射的第二个用途是作为一种(快速的)IPC方法.这种共享内存区域与systemV 共享内存对象之间的区别在于区域中内存上的变更更会反应到底层的映射文件上.这种特性对哪些需要共享内存内容在应用程序或系统重启时能够持久化的应用程序来讲是非常有用的
		==================================================
		注意:这种IPC因为可以直接影响到底层文件上,所以掉电不丢失,在那些需要在程序或系统重启之后能够继承之前变化的程序是非常有用的
		==================================================
	
边界情况
	   mmap(0, 6000, prot, MAP_SHARED, fd, 0);
        字节偏移:0	                            5999 6000       8191 8192
内存区域         ----------------------------------------------------
               |  请求的映射尺寸                      |       剩余页  |
               -----------------------------------------------------
               <-----------可访问;映射到文件-------------------------><----产生SIGSEGV的引用---->
               |                                                   |
               |                    	                           |
               |                     	                           |
               ----------------------------------------------------------------------------
映射文件        |           文件的真实映射区域                          |  未被映射
(9500字节)      ----------------------------------------------------------------------------
               0                                               8191 8192                 9499

	由于映射的大小不是系统分页大小的整数倍,因此它会被向上舍入到系统分页大小的下一个整数倍.由于文件大小要大于这个被向上舍入的大小,因此文件中对应字节会像上图那样被映射
	试图访问映射结尾之外的字节将会导致SIGSEGV信号的产生
	
	当映射扩充过了底层文件的结尾处,情况就变得复杂了
		mmap(0, 8192, prot, MAP_SHARED, fd, 0);
字节便宜:   0               2199 2200                  4095 4096                     8191 8192
内存区域    ------------------------------------------------------------------------------
          |                   |   剩余页(0s)              |                              |
          -------------------------------------------------------------------------------
          <-------------------><-------------------------><-----------------------------><----------------------->
            可访问,被映射到            可访问,没有被                    产生SIGBUS信号              产生SIGSEGV信号
            文件                      映射到文件
映射文件    --------------------
(2200字节) |                   |
          ---------------------
文件偏移   0                  2199
	从上图看出来,创建一个大小超过底层文件大小的映射可能是无意义的,但是通过扩展文件的大小 (如使用ftruncate, write()),可以使得这种映射中之前不可访问的部分变得可用

内存保护和文件访问模式交互
	一般来讲,PROT_READ,PROT_EXEC->O_RDONLY, O_RDWR
	1.所有内存保护组合与使用O_RDWR标记打开文件是兼容的
	2.没有内存保护组合--哪怕仅仅是PROT_WRITE--与使用O_WRONLY标记开大的文件是兼容的(导致EACCESS错误的发生).这与一些硬件架构不允许对一个分页的只写访问这样一个事实是一致的
	3.对于使用O_RDONLY打开的文件
	   对于一个MAP_PRIVATE映射来讲,在mmap()中可以指定任意的内存保护组合,因为对MAP_PRIVATE分页内容的修改不会被写入到文件中
	   对于MAP_SHARED,唯一和O_RDONLY兼容的标志是PROT_READ 或PROT_READ | PROT_EXEC

同步映射区域:msync()
	#include <sys/mman.h>
	int msync(void *addr, size_t length, int flags);
		returns 0 on success, or -1 on error;
	其主动刷新数据到被映射的文件中,还允许一个应用程序确保在可写入映射上发生的更新会对在该文件上执行read()的其他进程可见
	flags参数
	MS_SYNC
		阻塞直到内存区域中所有被修改过的分页被写入到底层磁盘为止
	MS_ASYNC
		执行一个异步的文件写入.内存区域中被修改过的分页在后面某个时刻被写入磁盘并立即对相应文件区域中执行read()的其他进程可见
	另一种区分这两个值的方式可以表述为在MS_SYNC操作之后,内存区域会与磁盘同步,而在MS_ASYNC操作之后,内存区域仅仅是与内核高速缓冲区同步
	
	如果不做处理.MS_ASYNC或由pdflush刷新到磁盘上,你也可以通过fsync(),fdatasync()来主动刷新高速缓冲区到磁盘中,或者通过posix_fadvise() POSIX_FADV_DONTNEED操作启动一个异步的分页写入
	MS_INVALIDATE
		使映射数据的缓存副本失效.当内存区域中所有被修改过的分页被同步到文件中之后,内存区域中所有与底层文件不一致的分页会被标记为无效.当下次引用这些分页时会从文件的相应位置处复制相应的分页内容,其结果是其他进程对文件做出的所有变更将会在内存区域中可见
	
	与很多其他现代unix实现一样,linux提供了一个所谓的同一虚拟内存系统.这表示内存映射和高速缓冲区块尽可能地共享相同的物理内存分页.因此通过映射获取的文件试图与通过IO系统调用,read(),write()获得的文件试图总是一致的,而msync()的唯一用途是强制将一个映射区域中的内容写入到磁盘
	不管怎样,SUSv3并没有要求实现统一虚拟内存系统,并且并不是所有的unix实现都提供了同一虚拟内存系统.在这类系统上需要调用msync()来使得一个映射上所发生的变更对其他read()该文件的进程可见,并且在执行逆操作时需要使用MS_INVALIDATE标记来使得
	其他进程对文件所做出的写入对映射区域可见.使用mmap()和io系统调用操作同一个文件的多进程应用程序如果希望可被移植到不具备统一虚拟内存系统的系统之上的话就需要恰当地使用msync()

其他的mmap()标记
	MAP_ANONYMOUS  
	MAP_FIXED
	MAP_LOCKED
	MAP_HUGETLB
	MAP_NORESERVE
	MAP_PRIVATE
	MAP_POPULATE
	MAP_SHARED
	MAP_UNINITIALIZED
匿名映射
	MAP_ANONYMOUS和/dev/zero
	在linux上,使用mmap()创建匿名映射存在两种不同单等价的方法
	1.在flags中指定MAP_ANONYMOUS,对fd的值忽略
	2.打开/dev/zero设备文件并将得到的文件描述符传递给mmap()
	私有匿名映射
	fd = open("/dev/zero", O_RDWR);
	addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
	glibc中当malloc分配超过(MMAP_THRESHOLD(128kB))时采用mmap
	
	共享匿名映射
	addr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);

重新映射一个映射区域:mremap()
	在大多数unix实现上一旦映射被创建,其位置和大小就无法改变了,但是在linux 中可以(不可移植)
	 #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <sys/mman.h>

       void *mremap(void *old_address, size_t old_size,
                    size_t new_size, int flags, ... /* void *new_address */);
      On  success  mremap()  returns a pointer to the new virtual memory area.  On error, the value MAP_FAILED (that is, (void *) -1) is returned, and errno is set
       appropriately.
	flags的值
		MREMAP_MAYMOVE
		MREMAP_FIXED,只能和MREMAP_MAYMOVE一起使用,如果指定了这个标记,mremap()会接受一个额外参数 void *new_address,改参数指定了一个分页对齐的地址,并且映射会被迁移至该地址处.所有之前在由new_address和new_size确定的地址范围之内的映射将会被接触映射
	
	在linux上,realloc()函数使用mremap()来高效地为malloc()之前使用mmap()MAP_ANONYMOUS分配的大内存块重新指定位置.使用mremap()来完成这种任务使得在重新分配空间的过程中避免复制字节成为可能


MAP_NORESERVE和过度利用交换空间
	懒交换预留:内核只在需要用到映射分页的时候(即当应用程序访问分页时)为它们预留交换空间.它的一个优点是应用程序总共使用的虚拟内存量能够超过RAM+交换空间的总量
		懒交换预留允许交换空间被过度利用.这种方式能够很好的工作,只要所有进程都不试图访问整个映射,但如果所有应用程序都试图访问真个映射,那么RAM和交换空间就被耗尽.在这种情况下,内核会通过杀死系统中的一个或多个进程来降低内存压力
	内核如何处理交换空间的预留是由调用mmap()时是否使用了MAP_NORESERVE标记以及影响系统层面的交换空间过度利用操作的/proc接口来控制的
	overcommit_memory值				是否在mmap()调用中指定了MAP_NORESERVE
										否						是
			0						拒绝明显的过度利用			允许过度利用
			1						允许过度利用				允许过度利用
			2					    严格的过度利用				严格的过度利用
	拒绝过度利用意味着大小不超过当前可用空闲内存是被允许的.既有的分配可能会被过度利用(因为它们可能不会使用映射的所有分页)
	从linux2.6起,1的含义与之前的内核中正数的含义一样,但2或更大则会导致使用采用严格的过度利用.在这种情况下,内核会在所有mmap()分配上执行严格的记账并将系统中此类分配的总量控制在小于或等于
		[swap size ] + [RAM size ] * overcommit_ratio /100
		overcommit_ratio的值是一个整数--用百分比表示--它位于linux特有的/proc/sys/vm/overcommit_ratio文件中.其默认值是50
			其表示内核最多可分配的空间为系统RAM总量的50%,只要所有进程不同时试图全部用完给它们分配的内存,那么这种空间的分配就不会有问题
	注意过度利用监控只适用于下面这些映射
	1.私有可写映射(包括文件和匿名映射),这种映射的交换"开销"等于所有适用该映射的进程为该映射所分配的空间的综合
	2.共享匿名映射,这种映射的交换"开销"等于映射的大小(因为所有进程共享该映射).
	
	为只读私有映射预留交换空间是没有必要的,,因为映射中的内存是不可变更的,从而无需使用交换空间.共享文件映射也不需要使用交换空间,因为映射文件本身担当了映射的交换空间
	
	当一个子进程在fork()调用中继承了一个映射时,它将会继承该映射的MAP_NORESERVE设置

OOM杀手
	上面提及过当使用懒交换预留时,如果应用程序试图使用整个映射的话就会导致内存被耗尽.在这种情况下,内核会通过杀死进程来缓解内存消耗情况--out of memory (OOM)杀手
	被OOM杀手杀死的进程的因素有:
	1.一个进程消耗的内存越多,越有可能被杀死
	2.是否创建了很多子进程
	3.进程是否拥有一个较低的nice值
	内核一般不会杀死下列进程
		1.特权进程
		2.正在访问裸设备的进程
		3.已经运行了很长时间或已经消耗了大量的CPU的进程,因为杀死他们可能会导致丢失很多工作
	/proc/PID/oom_score:
		给出了在需要调用OOM杀手时内核赋给每个进程的权重.权重越大,被杀的可能性就越大
	/proc/PID/oom_adj
		能够影响一个进程的oom_score值;这个文件被设置成范围-16-+15之间的任意一个值,其中负数会减小oom_score值,正数会增大oom_score值,特殊值-17会完全将进程从OOM杀手的候选目标中删除
			
MAP_FIXED标记
		强制内核解释mmap()中addr中的地址,而不是作为一个提示,如果指定了这个标志,则addr必须是分页对齐的,不建议指定这个标志
		然而,还是存在一个可移植应用程序需要使用MAP_FIXED的情况.如果在调用mmap()时指定了MAP_FIXED,并且内存区域的起始区域的起始位置为addr,覆盖的length字节与之前的映射分页重叠了,那么重叠的分页会被新映射替代.使用这个特性可以可移植地将一个文件(或多个文件)
		的多个部分映射进一块连续的内存区域
		移植性最好的方式:
			1.使用mmap()创建一个匿名映射.addr = NULL, flags中不指定MAP_FIXED,这样就让内核选择一个虚拟地址了(可移植)
			2.使用一系列指定了MAP_FIXED标记的mmap()调用来将文件区域映射(即重叠)进在上一步中创建的映射的不同的部分中

非线性映射:remap_file_pages()
      每个mmap()调用都会创建一个独立的内核虚拟内存区域(VMA)数据结构.每个VMA的配置需要花费时间并且会消耗一些不可交换的内核内存.此外,大量的VMA会降低虚拟内存管理器的性能.特别地,当存在数以万计的VMA时处理每个分页故障所花费的时间会大幅提高
      /proc/PID/maps文件中的一行表示一个VMA
      
      从内核2,6开始,linux内核提供了remap_file_pages()系统调用来在无需创建多个VMA的情况下创建非线性映射
      1.使用mmap()创建一个映射
      2.使用一个或多个remap_file_pages()调用来调整内存分页和文件分页之间的对应关系(remap_file_pages()所做的工作是操作进程的页表)
      #define _GNU_SOURCE         /* See feature_test_macros(7) */
       #include <sys/mman.h>

       int remap_file_pages(void *addr, size_t size, int prot,
                            size_t pgoff, int flags);
       RETURN VALUE
       On success, remap_file_pages() returns 0.  On error, -1 is returned, and errno is set appropriately.
		在当前的实现上,remap_file_pages()仅使用于共享(MAP_SHARED)映射
