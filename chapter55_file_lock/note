混合使用加锁和stdio函数
	这里的问题是一个输入缓冲器在被加锁之前可能会被填满或者一个输出缓冲器在锁被删除之后可能被刷新.要避免这些问题可以采用下面这些方法
	1.使用read(),write()来替换stdio库来执行文件IO
	2.在对文件加锁之后立即刷新stdio流,并且在释放锁之前立即再次刷新这个流
	3.使用setbuf()之类的函数来禁用stdio缓冲,当然这可能会牺牲一些效率
劝告式和强制式加锁
	默认情况下文件锁是劝告式的,这表示一个进程可以简单地忽略另一个进程在文件上放置的锁.要使得劝告式加锁模型能够正常工作,所有访问文件的进程都必须要配合,即在执行文件IO之前需要在文件上放置一把锁.
	与之对应的是,强制式加锁系统会强制一个进程在执行IO时需要遵循从其他进程持有的锁

使用flock()给文件加锁
	#include <sys/file.h>
       int flock(int fd, int operation);
    returns  0 on success, or -1 on error;
    flock()系统调用在整个文件上放置一个锁.待加锁的文件是通过传入fd的一个打开着的文件描述符来执行的.operation可以取如下的值
		LOCK_SH		在fd引用的文件上放置一把共享锁
		LOCK_EX		在fd引用的文件上放置一把互斥锁
		LOCK_UN		解锁fd引用的文件
		LOCK_NB		发起一个非阻塞锁请求
	在默认情况下,如果另一个进程已经持有了文件上的一个不兼容的锁,那么flock()会阻塞.如果需要防止出现这种情况,那么可以在operation参数中对这些值取OR.在这种情况下,如果另一个进程持有文件上的一个不兼容的锁,那么flock()就不会阻塞,相反它返回-1并将errno设置成EWOULDBLOCK
	
	任意数量的进程可同时持有一个文件上的共享锁,但是在同一个时刻只有一个进程能够持有一个文件上的互斥锁(换句话说,互斥锁会拒绝其他进程的互斥和共享锁请求)
	
	假设进程A首先放置了锁
	进程A					进程B
					LOCK_SH			LOCK_EX	
	LOCK_SH			是				否
	LOCK_EX			否				否
	
	不管一个进程在文件上的访问模式是什么,它都可以在文件上放置一把共享锁或互斥锁
	
	锁转换的过程不一定是原子的.在转换过程中首先会删除既有的锁,然后创建一个新锁.在这两部之间另一个进程对一个不兼容的未决请求可能会得到满足.如果发生了这种情况,那么转换过程会被阻塞,或者在指定了LOCK_NB的情况下转换过程会失败并且进程会丢失其原先持有的锁

锁继承与释放的语义
	flock()的LOCK_UN可以释放一个文件锁
	锁会在相应的文件描述符被关闭之后自动释放.
		通过flock()获取的文件锁是和打开的文件描述符而不是文件描述或文件i-node本身相关联的;这意味这dup... fcntl()F_DUPFD操作,新文件描述符会引用同一个文件锁,
		 下面的代码会释放这个锁
		 flock(fd, LOCK_EX);
		 newfd = dup(fd);
		 flock(newfd, LOCK_UN);
		如果已经通过了一个特定的文件描述符获取了一个锁并创建了该文件描述符的一个或多个副本,如果不显式地执行一个解锁操作-只有当所有的描述符副本都被关闭之后锁才会被释放
		
		如果open()获取第二个引用同一个文件的描述符,那么flock()会将第二个描述符当成一个不同的描述符.执行下面的代码,第二个flock()会阻塞
		fd1 = open("a.txt", O_RDWR);
		fd2 = open("a.txt", O_RDWR);
		flock(fd1,LOCK_EX);
		flock(fd1, LOCK_EX);
		这样一个进程就能使用flock()来将自己锁在一个文件之外了. ----------------------fcntl()返回的记录锁无法获取相同的效果
		fork()一个子进程和dup的效果一样
			有时候可以利用这些语义将一个文件锁从父进程(原子的)传输到子进程:在fork()之后,父进程关闭其文件描述符,然后锁就在子进程的控制之下了----------------------fcntl()返回的记录锁无法获取相同的效果
		
		通过flock()创建的锁在exec()中会得到保留(除非设置了close-on-exec,而且文件描述符是最后一个)
		
		程序中应该只使用一种文件加锁的方法,因为flock()和fcntl记录锁两个一起用这个结果是未定义的

flock()的限制
	１．只能对整个文件加锁．这种颗粒度太大，影响进程之间的并发性．
		例如，假设存在多个进程，其中各个进程都想要同时访问同一个文件的不同部分，那么通过flock()加锁会不必要地阻止这些进程并发完成这些操作
	2.通过flock()只能放置劝告式锁
	3.很多NFS实现不识别flock()放置的锁
	fcntl()加锁模型弥补了这些不足
	因为历史原因，linux NFS服务器不支持flock()锁，从内核2.6.12起，linux　ＮＦＳ服务器通过将flock()锁实现成整个文件上的一个fcntl()锁来支持flock()锁．这种做法在混合服务器上的
	BSD锁和客户端上的BSD锁时会导致一些奇怪的结果：客户端通常无法看到服务器的锁，反之亦然

使用fcntl()给记录加锁
	使用fcntl()能够在一个文件的任意部分上放置一把锁，这个文件部分既可以是一个字节，也可以是整个文件．这种形式的文件加锁通常被称为记录加锁，但这种称谓是不恰当的，因为unix上的文件是一个字节序列
		，并不存在记录边界的概念，文件记录的概念只存在于应用程序中
	它有时又被称为POSIX文件加锁
	
	SUSv3要求普通文件支持记录加锁，同时也允许其他文件类型也支持文件加锁，尽管记录锁通常只有在应用于普通文件上时才有意义（因为对于大多数其他文件类型，讨论文件中所含的数据的字节范围是毫无意义的），
		但是在ｌｉｎｕｘ上可以将一个记录锁应用在任意类型的文件描述符上
	
	创建或删除一个文件锁的fcntl()调用形式如下：
	struct flock flockstr;
	// set flockstr
	fcntl(fd, cmd, &flockstr);
	struct flock {
               ...
               short l_type;    /* Type of lock: F_RDLCK,
                                   F_WRLCK, F_UNLCK */      读，　写，删除
               short l_whence;  /* How to interpret l_start:
                                   SEEK_SET, SEEK_CUR, SEEK_END */
               off_t l_start;   /* Starting offset for lock */
               off_t l_len;     /* Number of bytes to lock */　 如果是０，表示直到文件末尾
               pid_t l_pid;     /* PID of process blocking our lock
                                   (set by F_GETLK and F_OFD_GETLK) */
               ...
           };
   读锁－共享锁，写锁是一个互斥锁，只有一个进程能够持有一把写锁，并且这把锁会将其他进程的写锁和读锁排除在外
	读锁－＞打开文件以允许读，写锁打开文件以允许写，如果要放置这两把锁，就必须要O_RDWR;如果在文件上放置一把和文件访问模式不兼容的锁时会导致一个EBADF错误
	l_start值可以小于０，只要最终得到的文件位置不会小于文件的起始位置即可
	l_len字段包含了一个指定待加锁的字节数的整数，其起始位置由l_whence和l_start定义．
		对文件结尾之后并不存在的字节进程加锁是可以的，但无法对文件起始位置之前的字节进行加锁
	
	一般来讲，应用程序应该只对所需的最小字节范围进行加锁
	在某些情况下，需要对最小范围进行限定，在诸如NFS,CIFS之类的网络文件系统上混用记录锁和mmap()调用会导致不期望的结果．只有在锁也是分页对齐的情况下，一切正常工作
	
	l_len指定为０有特殊含义，多l_start,l_whence确定的起始位置到文件结尾位置之内的所有字节加锁，不管文件增长到多大
	
	cmd参数
	F_SETLK ，这个在请求得不到满足时，立刻返回，返回错误EAGAIN或EACCESS
	F_SETLKW　和F_SETLK一样，除了这个在请求一个和已经存在的锁不兼容的锁时会阻塞
	注意：
		fcntl()要么会锁住指定的整个区域，要么就不会对任何字节加锁，不存在只锁住请求区域中那些当前未被锁住的字节的概念
		
	下面的这个cmd可以用来确定是否可以在一个给定的区域上放置一把锁
	F_GETLK
		检测是否能够获取flockstr指定的区域上的锁，但实际不获取这把锁．l_type必须是F_RDLCK, F_WRLCK.flock是一个值－结果参数，在返回时包含了有关　是否能够放置指定的锁的信息
			如果允许加锁，那么l_type == F_UNLCK,并且剩余的部分保持不变
			如果存在一个不兼容的锁，那么flockstr会返回与那些锁中其中一把锁（无法确定是哪把），同时更新l_type, l_stat, l_len, l_whence(总是返回SEEK_SET),以及持有这把锁的进程的进程ID(l_pid)
	注意：
		在F_GETLK的fcntl()返回之后，返回的flockstr可能过时了，你下面进行F_SETLK,F_SETLKW可能和F_GETLK指示的不一样

锁获取和释放的细节
	１．解锁一块文件区域总是会成功．即使当前并不持有一块区域上的锁，对这块区域解锁也不是一个错误
	２．在任何一个时刻，一个进程只能持有一个文件的某个特定区域上的一种锁．在之前已经锁住的区域上放置一把新锁会导致不发生任何事情（新锁的类型和既有锁的类型是一样的）或原子地将既有锁转换成新模式．在
		后一种情况中，当将一个读锁转换成写锁时需要为调用返回一个错误（F_SETLK）或阻塞（F_SETLKW）做好准备
	３．一个进程永远都无法将自己锁在一个文件区域之外　－－　flock()可以
	4.在已经持有的锁中间放置一把模式不同的锁会产生三把锁（同一个进程中）；
		与之相反的是，获取和模式相同的一把既有锁相邻或重叠的第二把锁会产生单个覆盖两把锁的合并区域的聚合锁
	５．在文件区域锁方面，关闭一个文件锁描述符具备一些不寻常的语义，后面后讲到

死锁
	F_SETLKW获取记录锁有可能产生死锁，在记录锁模型上，记录锁不会让两个进程阻塞，它会在这种死锁的情况下，解除一个进程的阻塞，并返回EDEADLK错误，linux上是选择最近的fcntl()那个调用，而其他unix实现可能不是这样，因此可移植的程序，需要未每个F_SETLKW调用处理EDEADLOCK做好准备
		即使多个不同文件上防止锁时，也能检测出死锁的情形，比如，　循环死锁，进程A等待获取被进程Ｂ锁住的区域上的锁，进程Ｂ等待进程Ｃ持有的锁，进程Ｃ等待进程Ａ持有的锁，这种情况
		
锁继承和释放的语义
	１．由fork()创建的子进程不会继承记录锁
	２．记录锁在exec()中会得到保留
	３．一个进程中的所有线程会共享同一组记录锁
	４．记录锁同时与一个进程和一个i-node关联
		从这种关联关系可以得出一个毫不意外的结果就是当一个进程终止之后，其所有记录锁会被释放．另一个稍微有点出乎意料的结果是当一个进程关闭了一个文件描述符之后，进程持有的对应文件上的所有锁会被释放，
		不管这些锁是通过哪个文件描述符获得的
		下面的代码．close(fd2)会将锁释放
		struct flock f1;
		fl.l_type = F_WRLCK;
		fl.l_whence = SEEK_SET;
		fl.l_start = 0;
		fl.l_len = 0;
		fd1 = open("testfile", O_RDWR);
		fd2 = open("testfile", O_RDWR);
		fcntl(fd1, cmd, &fl);
		close(fd2);
	
	 不管引用同一个文件的各个描述符是如何获得的以及不管描述符是如何被关闭的，上面最后一点描述的语义都是适用的

锁定饿死和排队加锁请求的优先级
	当多个进程必须要等待以便能够在当前被锁住的区域上放置一把锁时，一系列的问题就出现了
	一个进程是否能够等待以便在由一系列进程放置读锁的同一块区域上放置一把写锁并因此可能会导致饿死？在ｌｉｎｕｘ上（以及很多其他unix实现上），一系列的读锁确实能够导致一个被阻塞的写锁饿死，甚至无线地饿死
	在linux的规则如下：
		１．排队的锁请求被准许的循序是不确定的．如果多个进程正在等待加锁，那么它们被满足的循序取决于进程的调度
		２．写者并不必读者拥有更高的优先级，反之亦然
		在其他系统上这些论断可能是不正确的．在一些unix实现上，锁请求的服务是按照FIFO的循序来完成的，并且读者比写者拥有更高的优先级

强制加锁
	在使用劝告式锁时，应用程序的设计者需要
	1.为文件设置适合的所有全，（或组所有权）以及权限以防止非协作进程执行文件ＩＯ
	２．通过在执行ＩＯ之前获取恰当的锁来确保构成应用程序的进程互相协作
	
	在linxu中使用强制式加锁需要在待加锁的文件的文件系统以及每个待加锁的文件上启用这一项功能．通过在挂载文件系统时使用 -o mand 选项能够在该文件系统上启用强制式加锁
		mount -o mand /dev/sda10 /testfs
	在程序中可以通过在调用mount(2)时指定MS_MANDLOCK标记来取得同样的效果
	
		mount | grep  sda10
		/dev/sda10 on /testfs type ext3 (rw,mand)
	文件上强制式加锁的启用是通过开启set-group-ID权限位和关闭group-execute权限来完成的．这种权限位组合在其他场景中是毫无意义的
	在shell中可以按照下面的方法在一个文件上启用强制式加锁
		chmod g+s,g-x /testfs/file
	在一个程序中可以通过使用chmod()或fchmod()恰当地设置文件上的权限来启用该文件上的强制式加锁
	当显示一个启用了强制式加锁权限位的文件的权限时，ls(l)会在group-execute权限列中显示一个S
	ls -l /testfs/file
	-rw-r-Sr-- 1 mtk	users	0 Apr 22 14:11 /testfs/file

强制式加锁对文件ＩＯ操作的影响
	在被写或读锁锁住的强制式锁的文件区域上执行一个写，或者在被写锁锁住的区域上执行一个读操作；要看打开文件时的标记，O_NONBLOCK-有这个标记，立即返回错误并EAGAIN,没有这个标记，则阻塞
	同样适用于truncate()和ftruncate()，前提是它们尝试从中增加或删除字节的文件当前被另一个进程锁住（为了读或者写）了
	这个强制式锁也可能产生死锁，系统针对这种情况的处理方式和fcntl()死锁的方式一样，选择死锁中的一个write()系统调用失败并返回EDEADLK错误
	使用O_TRUNC标记的open()一个文件在存在其他进程持有该文件任意部分上的一个读锁或写锁是会立即失败EAGAIN错误
	
	如果存在进程持有一个文件任意部分上的强制式读锁或写锁，那么就无法在改文件上创建一个共享内存映射
	同样，如果一个文件参与了一个共享内存映射，那么就无法在该文件的任意部分放置一把强制式锁．
		这两种情况中，相关的系统调用会立即失败并返回EAGAIN错误

强制式加锁警告
	其所其的作用其实并没有那么大，它存在一些潜在的缺陷和问题
	1.只要在父目录上拥有适合的权限就能够与一个文件断开链接，其不能阻止删除文件
	２．在一个可公开的文件上启用强制式锁之前需要经过深思熟虑，因为即使是特权级才能也无法覆盖一个强制式锁．恶意用户可能会持续地持有该文件上的锁以制造拒绝服务攻击
		在大多是情况下可以通过关闭set-group-ID为来使得改文件再次可访问，但当强制式文件锁造成系统挂起就无法这样做了
	３．使用强制式锁存在性能开销．每次执行ＩＯ之前都要检查是否锁冲突，如果有大量的锁，那么会很影响ＩＯ效率
	４．其还会在应用程序设计上造成额外的开销，比如要对EAGAIN，EDEADLK错误进行处理
	5.因为在当前的linux实现中存在一些内核竞争条件，因此在有些情况下执行ＩＯ操作的系统调用在文件上存在本应该拒绝这些错误的强制式锁也能成功
	
/proc/locks文件
	cat /proc/locks 
	1: POSIX  ADVISORY  READ  2772 08:07:6308682 1073741826 1073742335
	2: POSIX  ADVISORY  WRITE 2734 08:07:4194720 1073741826 1073742335
	3: POSIX  ADVISORY  READ  3716 08:07:4195949 128 128
	4: POSIX  ADVISORY  READ  3716 08:07:4194478 1073741826 1073742335
	5: POSIX  ADVISORY  WRITE 3631 08:05:1310868 0 0
	6: POSIX  ADVISORY  WRITE 2772 08:07:6430823 0 EOF
	...
	46: FLOCK  ADVISORY  WRITE 1360 00:16:6 0 EOF
	
	
	
