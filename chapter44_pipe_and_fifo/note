一个管道是一个字节流

从管道中读取数据
	试图从一个当前为空的管道中读取数据将会被阻塞直到至少一个字节被写入到管道中为止.如果管道的写入端被关闭了,那么从管道中读取数据的进程在读完管道中剩余的所有数据之后将会看到文件结束(即read()返回0)
管道是单向的
	在管道中数据的传递方向是单向的.管道的一段用于写入,另一端则用于读取
	
可以确保写入不超过PIPE_BUF字节的的操作是原子的
	如果多个进程写入同一个管道,那么如果它们在一个时刻写入的数据量不超过PIPE_BUF字节,那么就可以确保写入的数据不会发生相互混合的情况,其大小限制是至少是512,在linux系统上是4096个字节,可以通过fpathconf(fd, _PC_PIPE_BUF)来获取
	当写入管道的数据块超过了PIPE_BUF字节,那么内核可能会将数据分割成几个较小的片段来传输,在读者从管道中消耗数据时再附加上后续的数据(WRITE()调用会阻塞直到所有数据被写入到管道为止)当只有一个进程向管道写入数据时,PIPE_BUF的取值就没有关系了.但如果有多个写进程,那么大数据块写入可能会被分解成任意大小的段(可能会小于PIPE_BUF字节),并且可能会出现与其他进程写入的数据交叉的现象
	只有在数据被传入到管道的时候PIPE_BUF限制才会起作用.当写入的数据达到PIPE_BUF字节时,write()会在必要的时候阻塞直到管道中的可用空间足以原子地完成操作.如果写入的数据大于PIPE_BUF字节,那么write()会尽可能地多传输数据以充满整个管道,然后阻塞直到一些读取进程从管道中移除数据.如果此类阻塞的write()被一个信号处理中断了,那么这个调用会被接触阻塞并返回成功传输到管道中的字节数.这个字节数会少于请求写入的字节数(所谓部分写入)
	注意:
	在linux2.2上,向管道写入任意数量的数据都是原子的,除非写入操作被一个信号处理器中断了,在linux2.4以及后续的版本上,写入数据量大于PIPE_BUF字节的所有操作都可能会被其他进程的吸入操作发生交叉(在版本号为2.2和2.4的内核中,实现管道的内核代码存在很大的差异)
	
管道的容量是有限的
	管道其实是一个在内核内存中维护的缓冲器,这个缓冲器的存储能力是有限的
	SUSv3并没有规定管道的存储能力.在早于2.6.11的linux内核中,管道的存储能力和系统页面的大小是一致的(4096),而从linux2.6.11起管道的存储能力是65536字节.其他unix实现上管道的存储能力可能是不同的
	一般来讲,一个应用程序无需直到管道的实际存储能力.如果需要防止写者进程阻塞,那么从管道中读取数据的进程应该被设成以尽可能快的速度从管道中读取数据
	从linux2.6.35开始可以修改一个管道的存储能力了 fcntl(fd	,F_SETPIPE_SZ,size)调用会将fd引用的管道的存储能力修改为至少size字节,fcntl(fd,F_GETPIPE_SZ)获取管道的存储能力,设置的范围在/proc/sys/fs/pipe-max-size中

创建和使用管道
#include <unistd.h>
int pipe(int filefds[2]);
	returns 0 on success, or -1 on error;
	读端filefds[0],写端filefds[1]
	
	ioctl(fd ,FIONREAD, &cnt)调用返回文件描述符fd所引用的管道或FIFO中未读取的字节数
	如果在两个进程中建立连个管道,来实现双向的数据传输,这个时候就需要考虑死锁的问题了,读进程可能在读取空管道-阻塞,写进程在写满管道-阻塞,这样就导致了死锁
	
管道允许相关进程间的通信
	由同一个父进程创建,fork()出来的子进程,或者递归下去的孙子进程...,管道一般用于兄弟进程之间的通信

关闭未使用管道文件描述符
	当管道中读取数据的进程会关闭其持有的管道写入描述符,这样当其他进程完成输出并关闭其写入描述符之后,读者就能够看到文件结束(在读完管道中的数据之后)
	写入进程关闭其持有的管道的读取描述符是出于不同的原因.当一个进程试图向一个管道写入数据但没有任何进程拥有该管道的打开着的读取描述符时,内核会向写入进程发送一个SIGPIPE信号.在默认情况下,这个信号会杀死进程,但进程可以捕获或忽略该信号,这样
	就会导致管道上的wirte()操作因EPIPE错误(已损坏的管道)而失败.收到SIGPIPE信号或得到EPIPE错误对标示出管道的状态是有用的,者就是为何需要关闭管道的未使用读取描述符的原因
	只有在所有进程中所有引用一个管道的文件描述符被关闭之后才会销毁该管道以及释放该管道占用的资源以供其他进程复用

将管道作为一个进程同步的方法
	通过父进程保留读取端,关闭写端;子进程关闭读端,保留写端;当所有子进程写完数据之后,然后关闭写端,父进程读到0,表示所有子进程都退出了,完成同步动作

使用管道连接过滤器
	防御性编程实践的要求最好将dup2放到一个if语句中
		if(pfd[1] != STDOUT_FILENO){
			dup2(pfd[1], STDOUT_FILENO);
			close(pfd[1]);
		}
通过管道与shell命令进行通信:popen()
	管道的一个常见用途是执行shell命令并读取输出或向其发送一些输入.popen()和pclose()函数简化了这个任务
	#include <stdio.h>
	FILE *popen(const char *command, const char *mode);
		returns file stream , or NULL on error;
	int pclose(FILE *stream);
		returns termination of status of child process, or -1 on error;
	popen()函数创建了一个管道,然后创建了一个子进程来执行shell,而shell又创建了一个子进程来执行command 字符串.mode参数是一个字符串,它确定调用进程是从管道中读取数据(mode 是r)还是将数据写入到管道中(mode 是w)(由于管道是单向的,因此无法在执行command中进行双向通信)
	当从管道中读取数据时,调用进程在command关闭管道的写入端之后会看到文件结束;当向管道写入数据时,如果command已经关闭了管道的读取端,那么调用进程会收到SIGPIPE信号并得到EPIPE错误
	一旦IO结束之后可以使用pclose()函数关闭管道并等待子进程中的shell终止,不应该使用fclose()函数,因为它不会等待子进程;pclose()在成功时会返回子进程中shekk的终止状态
	与system()一样,在特权进程中永远不应该使用popen()
	虽然system()和popen()以及pclose()之间存在很多相似之处,但也存在显著差异.这些差异源于一个事实,即使用system()时shell命令的执行是被封装在单个函数调用中的,而使用popen()时,调用进程和shell命令是并行的,然后会调用pclose().具体的差异如下:
		1.由于调用进程和被执行的命令是并行运行的,因此SUSv3要求popen()不忽略SIGINT,SIGQUIT信号;如果这些信号是从键盘上产生的,那么它们会被发送到调用进程和被执行的命令中
		2.由于调用进程在执行popen()和执行pclose()之间可能会创建其他子进程,因此SUSv3要求popen()不能阻塞SIGCHLD信号.这意味着如果调用进程在pclose()调用之前执行了一个等待操作,那么它就能够取得由popen()创建的子进程的状态.这样当后续调用popen()时,它就会返回-1,同时将errno设置为ECHILD,表示pclose()无法取得子进程的状态
		
不管system()还是popen()都需要做输入检查,如果输入的内容不是预期的,那么会引起不必要的错误
	比如预期输入的是列出文件名 /bin/ls -d %s 2>/dev/null ,如果不做输入检查,那么你输入的是"; rm *" -> /bin/ls -d; rm * 2>/dev/null 最终显然是不对的
	
管道和stdio缓冲
	由于popen()调用返回的文件流指针没有引用一个终端,因此stdio库对这种文件流应用全缓冲.者意味着当将Mode的值设置成w来调用popen()时,在默认情况下只有当stdio缓冲器被被充满或者使用pclose()关闭管道之后输出才会被发送到管道另一端的子进程,在很多情况下,这种处理方式不存在问题的.但是如果需要确保子进程能够立即从管道中接受数据,那么就需要定期调用
	  fflush()或使用setbuf(fp, NULL)来禁用stdio缓冲.当使用pipe()系统调用创建管道时,然后使用fopen()获取一个与管道的写入端对于的stdio流时也可以使用这项技术
	如果调用popen()的进程正在从管道中读取数据(即mode是r),那么事情就不是那么见到了.在这样情况下如果子进程正在使用stdio库,那么--除非它显式地调用了fflush()或setbuf()--其输出只有在进程填满stdio缓冲器或调用了fclose()之后才会对调用进程可用
	  如果正在从使用pipe()创建的管道中读取数据并且向另一端写入数据的进程正在使用stdio库,那么同样的规则也是适用的
	  如果这是一个问题,那么能采取的的措施就比较有限了,除非能够修改在子进程中运行的程序的源代码使之包含对setbuf()或fflush()调用
	如果无法修改源代码,那么可以适用伪终端来替换管道,一个伪终端是一个IPC通道,对进程来讲它就像一个终端.其结果是stdio库会逐行输出缓冲器中的数据

FIFO
	从语义上来讲，FIFO与管道类似，他们两者之间最大的差别在于FIFO在文件系统中有一个名称，并且其打开方式与打开一个普通文件是一样的ＩＯ系统调用了（如read(),write(),close()）.FIFO也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的．FIFO也被成为命令管道
    与管道一样，当所有引用FIFO的描述符被关闭之后，所有未被读取的数据会被丢弃
    使用mkfifo命令可以在shell中创建一个FIFO
		mkfifo [-m mode] pathname pathname是创建的FIFO的名称，-m选项用来指定权限mode,其工作方式与chmod命令一样
	当在FIFO（或管道）上调用fstat()和stat()函数时他们在stat结构的st_mode字段中返回一个类型为S_IFIFO的文件．当使用ls -l列出文件时，FIFO文件在第一列的类型为p,ls -F 会在ＦＩＦＯ路径名后面附加上一个管道符（|）
	
	#include <sys/stat.h>
	int mkfifo(const char *pathname, mode_t mode);
		return 0 on success, or -1 on error;
	一旦FIFO被创建了，任何进程都能够打开它，只要它能够通过常规的文件权限检测
	打开一个ＦＩＦＯ具备一些不寻常的语义
		一般来讲，使用FIFO时唯一明智的做法是在两端分别设置一个读取进程和一个写入进程．这样在默认情况下，打开一个ＦＩＦＯ一便读取数据（open()　O_RDNOLY）将会阻塞直到另一个进程打开FIFO以写入数据（open() O_WRONLY）为止．相应的，打开一个FIFO以
		写入数据将会阻塞直到另一个进程打开FIFO以读取数据为止．换句话说，打开一个FIFO会同步读取进程和写入进程．如果一个FIFO的另一端已经打开（可能是因为一对进程已经打开了FIFO两端），那么open()调用会立即成功
		
		在大多数unix实现上，当打开了一个FIFO时可以通过指定O_RDWR标志来绕过打开FIFO时的阻塞行为．这样open()就会立即返回，但无法使用返回的文件描述符在FIFO上读取和写入数据．这种做法破坏了FIFO的ＩＯ模型，SUSv3明确指明了以O_RDWR打开一个FIFO的结果是未知的
			可以通过在open()时通过O_NONBLOCK来完成这个任务（避免阻塞）
			在打开一个FIFO时避免使用O_RDWR标记还有另外一个原因．当采用那种方式调用open()之后，调用进程在从返回的文件描述符读取数据时永远也不会看到文件结束．因为永远都至少存在一个文件描述符被打开着以等待数据被写入FIFO,即进程从中读取数据的那个文件描述符
			
使用FIFO和tee(1)创建双重管道线
	tee :它将其从标准输入中读取的数据复制两份并输出：
		１．一份吸入到标准输出
		２．另一份写入到通过命令行参数指定的文件中
	将传递给tee命令的file参数设置为一个FIFO可以让两个进程同时读取tee产生的两份数据．
	mkfifo myfifo
	wc -l < myfifo &
	ls -l  | tee myfifo | sort -k5n
	除了上述用途之外，tee对于管道线调试和保存复杂管道线中某些中间节点的输出结果也是非常有用的

非阻塞ＩＯ
	O_NONBLOCK标志
	如果FIFO的另一端已经被打开，那么O_NONBLOCK对open()不会产生任何影响．只有当FIFO的另一端没有被打开的时候O_NONBLOCK标记才会其作用，而且具体产生的影响依赖于打来FIFO是用于读取还是用于写入的
	１．如果打开FIFO是为了读取，并且FIFO的写入端当前已经被打开，那么open()调用会立即成功
	２．如果打开FIFO是为了写入，并且还没有打开ＦＩＦＯ的另一端来读取数据，那么open()调用会失败，并将errno置为ENXIO
	为读取而打开FIFO和为写入而打开FIFO时O_NONBLOCK标记所起的作用不同是有原因的．
		当FIFO的另一个端没有写着打开时打开一个ＦＩＦＯ以便读取数据是没有问题的，因为任何试图从FIFO读取数据的操作都不会返回任何数据．但当试图向没有读者的FIFO中写入数据时将会导致SIGPIPE信号产生以及write()返回EPIPE错误
	在打开一个FIFO时使用O_NONBLOCK标记存在两个目的
		1.它允许单个进程打开一个FIFO的两端．这个进程会首先打开FIFO时指定O_NONBLOCK标记以便读取数据，接着打开FIFO以便写入数据
		2.它防止打开两个FIFO的进程之间产生死锁
	发生死锁的情景：
		进程x						进程ｙ
		１．打开FIFO A准备读取数据	　	１．打开ＦＩＦＯ　Ｂ准备读取数据
		２．打开FIFO　B准备写入			２．打开FIFO A准备写入

使用NONBLOCK对管道或FIFO读写时的语义
读取：
	从一个包含ｐ字节的管道或者FIFO中读取ｎ字节的语义
	是否启用了O_NONBLOCK							管道或FIFO中可用的数据字节p
						p=0,写入端打开	p=0,写入端关闭	 p < n 			p>=n
		否				阻塞				返回０（EOF）		读取p字节			读取n字节
		是				失败(EAGAIN)		返回０（EOF）     读取p字节         读取n字节
	
写入	
	向一个管道或FIFO写入n字节的语义
	是否启用了O_NONBLOCK					读取端打开								读取端关闭
							n <= PIPE_BUF			n > PIPE_BUF
		否				原子地写入ｎ字节，可能		写入n字节，可能阻塞，知道足够的
						阻塞，知道足够的数据被		数据被读取以便结束write,数据可
						读取以便继续执行write		能会与其他进程写入的数据发生交叉
		                                                                        SIGPIPE+
		是				如果空间足以以及写入ｎ		如果空间足以写入一些字节，那么		EPIPE
		　　				字节，那么write会原子		写入的字节数在１到n之间(可能
		　　				地成功，否则就失败　　		会与其他进程写入的数据发生交叉
		　　				(EAGAIN)　　　　　　　　　　		否则write会失败EAGAIN

在使用O_NONBLOCK写时，主要看写的数据是不是在PIPE_BUF范围内，其主要要保证原子性的语义，如果是要原子性，则不能产生部分写，如果不是原子性的(n> PIPE_BUF)则可以部分写


